\chapter{归约}


\section{归约的概念}

对于许多问题来说，寻求一个直接的解答、构造一个直接解决问题的算法是非常困难的。我们早已习惯通过变换问题的结构、挖掘问题的性质，在一个困难的问题中抽取出模型，
然后用已有的算法来解决，这就是问题与问题之间的归约。
在问题求解的过程中，归约使用的如此频繁，甚至很多时候我们都没有意识到自己实际上已经将一个问题归约成了另一个问题。问题与问题之间转化的过程
通常隐含了归约的过程。例如我们在二进制计算机中已有加减法、移位和平方三种运算，我们可以在这些运算的基础上构造出乘法运算：
$$a\times b = \left( (a+b)^2 - (a^2 + b^2) \right) \times 2^{-1}.$$

%将二部图匹配归约到网络最大流。

%将最大权闭包归约到最小割。

%子树查询变为区间查询。

%GSS2中查询的归约。

%区间询问。

归约中最常见，也是最简单的形式如图 \ref{fig:reduction-show} 所示。为了求解问题A，我们使用一个算法将A问题的输入转换为B问题的输入，求解B问题后
再将B问题的输出转换为A问题的输出。

\begin{figure}[h]
 \center
 \begin{tikzpicture}
  \matrix (m) [matrix of nodes,row sep=1.5em,column sep=1.5em,minimum width=1em]
  {
     问题A输入 &  输入转换  &  输出转换   & 问题A输出 \\
               & 问题B输入 &           & \\
               & 问题B算法 & 问题B输出 & \\
  };
  \path[-stealth]
    (m-1-1) edge (m-1-2) (m-1-3) edge (m-1-4)
    (m-1-2) edge (m-2-2)
    (m-2-2) edge (m-3-2)
    (m-3-2) edge (m-3-3) (m-3-3) edge (m-1-3)
;
  \node (thebox) [rectangle, draw=black, inner sep=1em, fit = (m-1-2) (m-3-3)] {};
 \end{tikzpicture}
 \caption{基本归约示意图}
 \label{fig:reduction-show}
\end{figure}

注意到归约前后问题的规模可能有很大的差别。在前面构造乘法运算例子中，1次乘法运算被归约成了3次平方运算、3次加减法运算和1次位运算，
即便考虑中间结果的大小，归约后问题的规模仍然与原问题同阶。

归约是复杂性理论证明中的常用手段。例如，我们想要检查``判定图中是否存在超过大小为$k$的团(Clique)''这一问题的难度。显然$\mathrm{Clique}\in\mathrm{NP}$。
我们已知SAT问题是NP-完全的，如果我们能在多项式时间内，将一个SAT问题的输入$C$转换成一个最大团问题的输入$G$，并且$G$存在大小为$k$的团当且仅当SAT问题可被满足，
我们就能得出``Clique问题至少和SAT问题一样难''的结论。如果存在这样的归约，Clique就是NP-完全的。

在实际解决问题时，归约在大多数时候意味着用一个更通用的算法，来解决一个相对简单的问题。
一个典型的例子是我们把二分图的匹配问题归约到网络最大流问题。直观上看，这个归约并没有使用到网络流问题的全部能力，
Dinic算法在求解这类具有特殊结构的网络流问题时有$O(\sqrt{V} E)$的时间复杂度。


\section{归约到CNF-SAT问题}

CNF-SAT问题(后简称为SAT问题)是一类十分重要的基本问题，其问题描述如下：

\begin{prob}[合取范式可满足性, CNF-SAT, SAT]
 给定一个合取范式(CNF)表示的逻辑公式$C = C_1 \land C_2 \land \ldots \land C_n$，其中每一个子句(clause) $C_i$都是
 若干变量$x_i$或$\neg x_i$的析取(即或运算连接的)。求每个变量的一个赋值($T$或$F$)，使$C$的值为真。例如
 $$(x_1)\land(\neg x_1 \lor x_2)\land(\neg x_2 \lor x_3)$$
 是可满足的，令$x_1=x_2=x_3=T$即可。
\end{prob}

SAT问题在计算机科学中有着十分重要的地位。对于每一个子句$C_i$中变量的个数不超过2的情况，2-SAT存在十分高效的算法；
但如果仅仅将这个限制放宽为$C_i$中变量个数不超过3，该问题就成为了NP-完全问题，这意味着所有NP问题都可以在多项式时间内归约到
3-SAT，SAT是最早被证明的NP-完全问题。

\begin{prob}[2-SAT]
 在SAT问题中，限制每个子句中包含的变量个数不超过2。不失一般性，我们假设每个子句都是$a\lor b (a \neq b)$的形式，其中$a, b$是变量$x_i$或$x_i$的取反$\neg x_i$。
\end{prob}

解决2-SAT问题的突破口是$(p\to q) = (\neg p \lor q)$。
我们可以将形如$a\lor b$的子句改写成蕴含的形式：$$(a\lor b) = (\neg a \to b) = (\neg b \to a) = (\neg a \to b) \land (\neg b \to a).$$
这样，2-SAT问题就被我们改写成了若干蕴含式的合取，此时问题的解决也十分明朗：建立有向图$G(V,E)$，其中$V$是由每个变量$x_i$和它的取反$\neg x_i$组成的，
而对于改写后的每一个蕴含式$a\to b$，都在图中添加一条由$a$指向$b$的边。
由于蕴含关系的传递性，若图中如果存在$x_i$到$\neg x_i$的路径，则说明2-SAT中包含矛盾，否则我们就可以依据蕴含关系求出2-SAT的一个解。
更进一步，因为$G$特殊的对称性(故意将一个析取式变换成了两个等价蕴含式的合取), $x_i$到$\neg x_i$存在路径总是意味着$\neg x_i$到$x_i$也存在路径，所以2-SAT最终被归约到有向图强连通分量问题的求解。
2-SAT适用于求解二元的约束关系，例如如下问题：
\begin{prob}[异或求解, XOR]
 给定非负整数权无向图$G(V, E, W)$，你需要为每一个结点$v$求一个整数标号$X_v$，使得对于每条边$\{u, v\}\in E$, $X_u \oplus X_v = W_{u,v}$。
 其中$\oplus$为按位异或运算。
\end{prob}

SAT是NP-完全问题，从目前的研究进展来看，设计一个算法能够高效地计算任意SAT问题的解是不现实的。但这并不意味着试图解决SAT问题的尝试完全是徒劳，其原因有二：
首先，SAT问题足够难，这样我们不仅可以把一些简单的问题归约到SAT，还可以将很多难问题归约到SAT，注意现实生活中的很多问题都是很困难的问题；
其次，SAT问题的形式十分特殊，问题的目标是求一个``满足约束条件的解''，而大量的现实问题都是要求在满足一定约束条件下的合法解。
许多NP-完全问题(例如哈密顿路问题)虽然能在多项式时间内与SAT互相归约，但把实际问题归约到它们却并不容易。
这些原因使归约到SAT成为了一类问题求解的标准途径。人们对SAT问题求解的需求增长，也刺激了对SAT问题求解的研究。
让我们高兴的是，即便SAT问题在理论上是十分困难的，但很多算法确实能非常高效地解决各种实际问题，
能够求解现实问题中数万个变量、数百万个子句的SAT问题实例，而且我们能从互联网上获取各种各样的SAT solver。
作为SAT solver的应用，我们首先介绍Exact Cover问题：

\begin{prob}[覆盖问题, Exact Cover]
 给定一个$n\times m$的01矩阵$A$，求一个行的集合$C\subseteq[n]$，满足对于任意的$j$, 
 $\sum_{i\in C} A_{i,j} = 1$。也就是说，我们要从$A$中取出若干行得到一个子矩阵，满足该子矩阵中每列恰好只有一个$1$。
 例如，若
 $$A = 
 \begin{pmatrix}
  0 & 0 & 0 & 1 & 0 & 1\\
  1 & 1 & 1 & 1 & 0 & 0\\
  1 & 0 & 1 & 0 & 1 & 0\\
  0 & 1 & 0 & 0 & 0 & 0\\
 \end{pmatrix},
 $$
 则$C=\{1, 3, 4\}$是一个合法的覆盖，而$\{1, 2, 4\}$则不是。
\end{prob}

% SPOJ 217
% 你在玩一个塔防小游戏，游戏在一张矩形地图上进行，地图上有4种格子，分别是防御塔、敌人、障碍和空地。你只能在游戏开始前调整防御塔的状态，虽然游戏开始以后敌人是不会动的，但你的目标是消灭所有的敌人，并保证防御塔之间不会误伤。

有些问题可以很自然地被归约到Exact Cover，例如下面提到的方块覆盖问题：

\begin{prob}[方块覆盖，Tetris]
给出一个$n\times n$的棋盘和一些给定的部件，棋盘上指定一些方格为空格。你需要用给定的部件不重叠地覆盖棋盘上所有的空格，每个部件最多只能使用一次。
\end{prob}

\begin{figure}[h]
 \center
 \begin{tikzpicture}[scale = 0.5]
  \draw[help lines] (0, 0) grid (8, 8);
  \draw[line width=0.5mm, fill=red!15] (0, 0) -- (1, 0) -- (1, 1) -- (3, 1) -- (3, 2) -- (1, 2) -- (1, 3) -- (0, 3) -- (0, 0);
  \draw[line width=0.5mm, fill=green!15] (1, 0) -- (5, 0) -- (5, 1) -- (4, 1) -- (4, 2) -- (3, 2) -- (3, 1) -- (1, 1) -- (1, 0);
  \draw[line width=0.5mm, fill=blue!15] (5, 0) -- (8, 0) -- (8, 3) -- (7, 3) -- (7, 1) -- (5, 1) -- (5, 0);
  \draw[line width=0.5mm, fill=yellow!15] (0, 3) -- (1, 3) -- (1, 2) -- (3, 2) -- (3, 4) -- (0, 4) -- (0, 3);
  \draw[line width=0.5mm, fill=red!15] (3, 2) -- (4, 2) -- (4, 1) -- (5, 1) -- (5, 2) -- (6, 2) -- (6, 4) -- (5, 4) -- (5, 3) -- (3, 3) -- (3, 2);
  \draw[line width=0.5mm, fill=yellow!15] (5, 1) -- (7, 1) -- (7, 3) -- (8, 3) -- (8, 4) -- (6, 4) -- (6, 2) -- (5, 2) -- (5, 1);
  \draw[line width=0.5mm, fill=blue!15] (0, 4) -- (2, 4) -- (2, 5) -- (1, 5) -- (1, 6) -- (2, 6) -- (2, 7) -- (0, 7) -- (0, 4);
  \draw[line width=0.5mm, fill=green!15] (2, 4) -- (3, 4) -- (3, 5) -- (4, 5) -- (4, 6) -- (3, 6) -- (3, 7) -- (2, 7) -- (2, 6) -- (1, 6) -- (1, 5) -- (2, 5) -- (2, 4);
  \draw[line width=0.5mm, fill=blue!15] (3, 6) -- (4, 6) -- (4, 5) -- (5, 5) -- (5, 4) -- (6, 4) -- (6, 6) -- (5, 6) -- (5, 7) -- (3, 7) -- (3, 6);
  \draw[line width=0.5mm, fill=red!15] (5, 6) -- (6, 6) -- (6, 4) -- (7, 4) -- (7, 7) -- (6, 7) -- (6, 8) -- (5, 8) -- (5, 6);
  \draw[line width=0.5mm, fill=green!15] (7, 4) -- (8, 4) -- (8, 8) -- (6, 8) -- (6, 7) -- (7, 7) -- (7, 4);
  \draw[line width=0.5mm, fill=yellow!15] (0, 8) -- (5, 8) -- (5, 7) -- (0, 7) -- (0, 8);
  \draw[line width=0.5mm, fill=gray!0] (3, 3) -- (3, 5) -- (5, 5) -- (5, 3) -- (3, 3);
 \end{tikzpicture}

 \caption{一个方块覆盖问题的实例}
 \label{fig:tetris}
\end{figure}

Exact Cover是一个NP-完全问题，使用Dancing Links数据结构的搜索配合一些启发策略是解决Exact Cover问题的通常手段。
为了充分利用SAT solver，我们现在将Exact Cover归约到SAT：我们为矩阵的每一行设置一个变量$x_i$，当$x_i=T$时，我们希望$i\in C$，相反当$x_i=F$时，$i\notin C$。
首先，我们希望矩阵中的每一列都被覆盖，因此对于每一列$j$，令$T_j = \{ i~|~ A_{i,j} = 1\}$, 则子句
$$\bigvee_{i \in T_j} x_i$$
代表了``第$j$列至少包含一个1''。
其次，我们希望每一列至多只有一个1。因此我们必须禁止某些行被同时选中，即对于每一对$(p,q)$，若第$p$行和第$q$行在同一列上有公共的1，我们还需要满足
$$\neg (x_p \land x_q) = (\neg x_p \lor \neg x_q).$$

将$n\times m$规模的Exact Cover归约到SAT问题后约有$O(m)$个$O(n)$大小的clause，以及$O(n^2)$个$O(1)$大小的clause，问题的整体规模并没有数量级上的提升，
这个归约可以用来解决很多问题，例如数独的求解。

\begin{figure}[h]
 \center

  \newcounter{row}
\newcounter{col}

\newcommand\setrow[9]{
  \setcounter{col}{1}
  \foreach \n in {#1, #2, #3, #4, #5, #6, #7, #8, #9} {
    \edef\x{\value{col} - 0.5}
    \edef\y{9.5 - \value{row}}
    \node[anchor=center] at (\x, \y) {\n};
    \stepcounter{col}
  }
  \stepcounter{row}
}

  \begin{tikzpicture}[scale=.5]

    \begin{scope}
      \draw (0, 0) grid (9, 9);
      \draw[very thick, scale=3] (0, 0) grid (3, 3);

      \setcounter{row}{1}
      \setrow { }{2}{ }  {5}{ }{1}  { }{9}{ }
      \setrow {8}{ }{ }  {2}{ }{3}  { }{ }{6}
      \setrow { }{3}{ }  { }{6}{ }  { }{7}{ }

      \setrow { }{ }{1}  { }{ }{ }  {6}{ }{ }
      \setrow {5}{4}{ }  { }{ }{ }  { }{1}{9}
      \setrow { }{ }{2}  { }{ }{ }  {7}{ }{ }

      \setrow { }{9}{ }  { }{3}{ }  { }{8}{ }
      \setrow {2}{ }{ }  {8}{ }{4}  { }{ }{7}
      \setrow { }{1}{ }  {9}{ }{7}  { }{6}{ }

      \node[anchor=center] at (4.5, -0.5) {一个数独问题};
    \end{scope}

    \begin{scope}[xshift=12cm]
      \draw (0, 0) grid (9, 9);
      \draw[very thick, scale=3] (0, 0) grid (3, 3);

      \setcounter{row}{1}
      \setrow { }{2}{ }  {5}{ }{1}  { }{9}{ }
      \setrow {8}{ }{ }  {2}{ }{3}  { }{ }{6}
      \setrow { }{3}{ }  { }{6}{ }  { }{7}{ }

      \setrow { }{ }{1}  { }{ }{ }  {6}{ }{ }
      \setrow {5}{4}{ }  { }{ }{ }  { }{1}{9}
      \setrow { }{ }{2}  { }{ }{ }  {7}{ }{ }

      \setrow { }{9}{ }  { }{3}{ }  { }{8}{ }
      \setrow {2}{ }{ }  {8}{ }{4}  { }{ }{7}
      \setrow { }{1}{ }  {9}{ }{7}  { }{6}{ }

      \node[anchor=center] at (4.5, -0.5) {数独问题的解};

      \begin{scope}[blue, font=\sffamily\slshape]
	\setcounter{row}{1}
	\setrow {4}{ }{6}  { }{7}{ }  {3}{ }{8}
	\setrow { }{5}{7}  { }{9}{ }  {1}{4}{ }
	\setrow {1}{ }{9}  {4}{ }{8}  {2}{ }{5}

	\setrow {9}{7}{ }  {3}{8}{5}  { }{2}{4}
	\setrow { }{ }{3}  {7}{2}{6}  {8}{ }{ }
	\setrow {6}{8}{ }  {1}{4}{9}  { }{5}{3}

	\setrow {7}{ }{4}  {6}{ }{2}  {5}{ }{1}
	\setrow { }{6}{5}  { }{1}{ }  {9}{3}{ }
	\setrow {3}{ }{8}  { }{5}{ }  {4}{ }{2}
      \end{scope}

    \end{scope}

  \end{tikzpicture}
 \caption{一个数独问题的实例}
 \label{fig:sudoku}
\end{figure}

\begin{prob}[数独问题, Sudoku]
 你需要在一个$9\times9$的方阵中填入1-9这9个数字，并且满足每行、每列以及9个粗线标出的$3\times3$方格中，1-9中的每个数字恰好出现一次。
 固定方阵中的一些数字，求一组可行的解。问题的例子如图 \ref{fig:sudoku} 所示。
\end{prob}


在数独的例子中，我们生成的SAT问题实例有$729$个变量($x_{i,j,k}$表示在$(i,j)$格子中填入字母$k$)，$10^4$数量级的子句数量，但一个好的SAT solver仍然能够在极少的时间内给出正确的解答。
事实上，即便我们将数独方阵的大小扩展到$16\times16$，问题实例的变量数上升到$4096$，子句数量上升到$10^5$数量级，SAT solver仍然能在数秒之内给出解答。


\begin{figure}[h]
 \center
 \begin{tikzpicture}
  \matrix (m) [matrix of nodes,row sep=2em,column sep=2em,minimum width=1em]
  {
     & Tetris & \\
     Sudoku & Exact Cover & SAT \\
     XOR & 2-SAT & 3-SAT\\
         & 强连通分量 & \\
  };
  \path[-stealth]
    (m-1-2) edge (m-2-2)
    (m-2-1) edge (m-2-2)
    (m-2-2) edge [stealth-stealth] (m-2-3)
    (m-3-1) edge (m-3-2)
    (m-3-2) edge (m-2-3)
    (m-3-2) edge (m-3-3)
    (m-3-3) edge [stealth-stealth] (m-2-3)
    (m-3-2) edge (m-4-2)
;
 \end{tikzpicture}
 \caption{SAT相关问题的归约关系\protect\footnotemark}
 \label{fig:sat-reduction}
\end{figure}
\footnotetext{广义的方块覆盖和数独问题都是NP-完全问题，它们能与SAT, Exact Cover互相归约。}

图 \ref{fig:sat-reduction} 中列举了与SAT有关的一系列问题之间的归约关系，我们看到，问题的归约并不是唯一的。SAT和Exact Cover都是NP-完全问题，它们之间可以相互归约；
2-SAT既可以被归约成一般的SAT问题从而调用SAT solver求解，也可以被归约成图中的强连通分量问题，用基于深度优先搜索的算法求解。
